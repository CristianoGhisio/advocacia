---
description: "Padr√µes de seguran√ßa baseados na metodologia THINK"
globs: ["**/*.ts", "**/*.tsx", "**/*.js", "**/*.jsx"]
alwaysApply: true
---

# üîí SEGURAN√áA - PADR√ïES DEFENSIVOS

## üõ°Ô∏è PRINC√çPIOS FUNDAMENTAIS

### üéØ **Security by Design**
- Implementar seguran√ßa desde o in√≠cio
- Valida√ß√£o rigorosa de todos os inputs
- Princ√≠pio do menor privil√©gio
- Defesa em profundidade (m√∫ltiplas camadas)

### üîç **Threat Modeling**
- Identificar assets cr√≠ticos
- Mapear vetores de ataque
- Implementar controles adequados
- Monitoramento cont√≠nuo

## üîê AUTENTICA√á√ÉO E AUTORIZA√á√ÉO

### üé´ **JWT Security**
```typescript
// ‚úÖ CORRETO: JWT seguro
interface JWTConfig {
  secret: string;
  expiresIn: string;
  issuer: string;
  audience: string;
}

const JWT_CONFIG: JWTConfig = {
  secret: process.env.JWT_SECRET!, // Nunca hardcode
  expiresIn: '15m', // Short-lived tokens
  issuer: 'vitasana-api',
  audience: 'vitasana-client'
};

export const generateToken = (payload: TokenPayload): string => {
  // Sanitizar payload
  const sanitizedPayload = {
    userId: payload.userId,
    role: payload.role,
    permissions: payload.permissions?.filter(p => VALID_PERMISSIONS.includes(p))
  };
  
  return jwt.sign(sanitizedPayload, JWT_CONFIG.secret, {
    expiresIn: JWT_CONFIG.expiresIn,
    issuer: JWT_CONFIG.issuer,
    audience: JWT_CONFIG.audience,
    algorithm: 'HS256' // Especificar algoritmo
  });
};

export const verifyToken = (token: string): TokenPayload => {
  try {
    return jwt.verify(token, JWT_CONFIG.secret, {
      issuer: JWT_CONFIG.issuer,
      audience: JWT_CONFIG.audience,
      algorithms: ['HS256'] // Prevenir algorithm confusion
    }) as TokenPayload;
  } catch (error) {
    console.error('üîí Token verification failed:', {
      error: error.message,
      timestamp: new Date().toISOString()
    });
    throw new UnauthorizedError('Invalid token');
  }
};
```

### üîë **Refresh Token Strategy**
```typescript
// ‚úÖ CORRETO: Refresh token seguro
export const refreshTokenService = {
  async generate(userId: number): Promise<string> {
    const token = crypto.randomBytes(32).toString('hex');
    const hashedToken = await bcrypt.hash(token, 12);
    
    await db.refreshToken.create({
      data: {
        userId,
        token: hashedToken,
        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days
        createdAt: new Date()
      }
    });
    
    return token;
  },
  
  async verify(token: string): Promise<number> {
    const tokens = await db.refreshToken.findMany({
      where: {
        expiresAt: { gt: new Date() }
      }
    });
    
    for (const storedToken of tokens) {
      const isValid = await bcrypt.compare(token, storedToken.token);
      if (isValid) {
        // Rotate token (usar apenas uma vez)
        await db.refreshToken.delete({
          where: { id: storedToken.id }
        });
        
        return storedToken.userId;
      }
    }
    
    throw new UnauthorizedError('Invalid refresh token');
  }
};
```

## üõ°Ô∏è INPUT VALIDATION E SANITIZA√á√ÉO

### ‚úÖ **Schema Validation**
```typescript
// ‚úÖ CORRETO: Valida√ß√£o rigorosa com Zod
import { z } from 'zod';

const CreateReservationSchema = z.object({
  serviceId: z.number().int().positive(),
  date: z.string().datetime().refine(date => {
    const reservationDate = new Date(date);
    const now = new Date();
    return reservationDate > now; // N√£o permitir datas passadas
  }, 'Data deve ser futura'),
  
  notes: z.string()
    .max(500, 'Notas muito longas')
    .optional()
    .transform(notes => notes ? sanitizeHtml(notes) : undefined),
    
  clientData: z.object({
    name: z.string()
      .min(2, 'Nome muito curto')
      .max(100, 'Nome muito longo')
      .regex(/^[a-zA-Z√Ä-√ø\s]+$/, 'Nome cont√©m caracteres inv√°lidos'),
      
    email: z.string()
      .email('Email inv√°lido')
      .transform(email => email.toLowerCase().trim()),
      
    phone: z.string()
      .regex(/^\+?[\d\s\-\(\)]+$/, 'Telefone inv√°lido')
      .transform(phone => phone.replace(/\D/g, ''))
  })
});

export const createReservation = async (req: Request, res: Response) => {
  try {
    // Valida√ß√£o rigorosa
    const validatedData = CreateReservationSchema.parse(req.body);
    
    // Log de auditoria
    console.log('üéØ Reservation Creation Attempt:', {
      userId: req.user?.id,
      serviceId: validatedData.serviceId,
      timestamp: new Date().toISOString(),
      ip: req.ip,
      userAgent: req.get('User-Agent')
    });
    
    const reservation = await reservaService.create({
      ...validatedData,
      userId: req.user!.id
    });
    
    res.status(201).json({
      success: true,
      data: reservation
    });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        success: false,
        error: 'Validation failed',
        details: error.errors
      });
    }
    
    console.error('‚ùå Reservation creation failed:', {
      error: error.message,
      userId: req.user?.id,
      timestamp: new Date().toISOString()
    });
    
    res.status(500).json({
      success: false,
      error: 'Internal server error'
    });
  }
};
```

### üßπ **Sanitiza√ß√£o de Dados**
```typescript
// ‚úÖ CORRETO: Sanitiza√ß√£o adequada
import DOMPurify from 'isomorphic-dompurify';
import validator from 'validator';

export const sanitizers = {
  html: (input: string): string => {
    return DOMPurify.sanitize(input, {
      ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'p', 'br'],
      ALLOWED_ATTR: []
    });
  },
  
  sql: (input: string): string => {
    return validator.escape(input);
  },
  
  filename: (input: string): string => {
    return input
      .replace(/[^a-zA-Z0-9.-]/g, '_')
      .replace(/_{2,}/g, '_')
      .substring(0, 255);
  },
  
  email: (input: string): string => {
    return validator.normalizeEmail(input, {
      gmail_lowercase: true,
      gmail_remove_dots: true,
      outlookdotcom_lowercase: true
    }) || '';
  }
};
```

## üîç SQL INJECTION PREVENTION

### üíâ **Parameterized Queries**
```typescript
// ‚úÖ CORRETO: Queries parametrizadas (Prisma)
export const reservaService = {
  async findByUser(userId: number, filters: ReservationFilters) {
    const whereClause: Prisma.ReservationWhereInput = {
      userId: userId, // Par√¢metro seguro
      ...(filters.status && { status: filters.status }),
      ...(filters.dateFrom && {
        date: { gte: new Date(filters.dateFrom) }
      }),
      ...(filters.dateTo && {
        date: { lte: new Date(filters.dateTo) }
      })
    };
    
    return await db.reservation.findMany({
      where: whereClause,
      include: {
        service: true,
        user: {
          select: { id: true, name: true, email: true }
        }
      },
      orderBy: { createdAt: 'desc' }
    });
  },
  
  // ‚ùå NUNCA FAZER: Query concatenada
  // async findByUserUnsafe(userId: number, status: string) {
  //   return await db.$queryRaw`
  //     SELECT * FROM reservations 
  //     WHERE user_id = ${userId} AND status = '${status}'
  //   `; // VULNER√ÅVEL A SQL INJECTION!
  // }
};
```

## üåê XSS PREVENTION

### üõ°Ô∏è **Content Security Policy**
```typescript
// ‚úÖ CORRETO: CSP headers
export const securityMiddleware = (req: Request, res: Response, next: NextFunction) => {
  // CSP rigoroso
  res.setHeader('Content-Security-Policy', [
    "default-src 'self'",
    "script-src 'self' 'unsafe-inline'", // Minimizar unsafe-inline
    "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com",
    "font-src 'self' https://fonts.gstatic.com",
    "img-src 'self' data: https:",
    "connect-src 'self' https://api.vitasana.com",
    "frame-ancestors 'none'",
    "base-uri 'self'",
    "form-action 'self'"
  ].join('; '));
  
  // Outros headers de seguran√ßa
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('X-Frame-Options', 'DENY');
  res.setHeader('X-XSS-Protection', '1; mode=block');
  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
  res.setHeader('Permissions-Policy', 'geolocation=(), microphone=(), camera=()');
  
  next();
};
```

### üîí **Output Encoding**
```typescript
// ‚úÖ CORRETO: Encoding de output
export const renderUserContent = (content: string): string => {
  // Escapar HTML entities
  return content
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;')
    .replace(/\//g, '&#x2F;');
};

// Para React (j√° faz escape autom√°tico)
const UserComment: React.FC<{ comment: string }> = ({ comment }) => (
  <p>{comment}</p> // React escapa automaticamente
);

// Para HTML din√¢mico
const UserComment: React.FC<{ comment: string }> = ({ comment }) => (
  <p dangerouslySetInnerHTML={{ 
    __html: DOMPurify.sanitize(comment) 
  }} />
);
```

## üîê CSRF PROTECTION

### üõ°Ô∏è **CSRF Tokens**
```typescript
// ‚úÖ CORRETO: Prote√ß√£o CSRF
import csrf from 'csurf';

const csrfProtection = csrf({
  cookie: {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict'
  }
});

app.use(csrfProtection);

// Endpoint para obter token CSRF
app.get('/api/csrf-token', (req, res) => {
  res.json({ csrfToken: req.csrfToken() });
});

// Frontend: incluir token em requests
const apiRequest = async (endpoint: string, data: any) => {
  const csrfResponse = await fetch('/api/csrf-token');
  const { csrfToken } = await csrfResponse.json();
  
  return fetch(endpoint, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRF-Token': csrfToken
    },
    body: JSON.stringify(data)
  });
};
```

## üìÅ FILE UPLOAD SECURITY

### üì§ **Secure File Handling**
```typescript
// ‚úÖ CORRETO: Upload seguro
import multer from 'multer';
import path from 'path';

const ALLOWED_MIME_TYPES = [
  'image/jpeg',
  'image/png',
  'image/webp',
  'application/pdf'
];

const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB

const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    // Diret√≥rio fora do webroot
    cb(null, '/var/uploads/temp');
  },
  
  filename: (req, file, cb) => {
    // Nome seguro
    const safeName = crypto.randomBytes(16).toString('hex');
    const ext = path.extname(file.originalname).toLowerCase();
    cb(null, `${safeName}${ext}`);
  }
});

const fileFilter = (req: any, file: Express.Multer.File, cb: any) => {
  // Validar MIME type
  if (!ALLOWED_MIME_TYPES.includes(file.mimetype)) {
    return cb(new Error('Tipo de arquivo n√£o permitido'));
  }
  
  // Validar extens√£o
  const ext = path.extname(file.originalname).toLowerCase();
  const allowedExts = ['.jpg', '.jpeg', '.png', '.webp', '.pdf'];
  if (!allowedExts.includes(ext)) {
    return cb(new Error('Extens√£o n√£o permitida'));
  }
  
  cb(null, true);
};

export const uploadMiddleware = multer({
  storage,
  limits: {
    fileSize: MAX_FILE_SIZE,
    files: 1
  },
  fileFilter
});

// Processar upload
export const handleFileUpload = async (req: Request, res: Response) => {
  try {
    if (!req.file) {
      return res.status(400).json({
        success: false,
        error: 'Nenhum arquivo enviado'
      });
    }
    
    // Valida√ß√£o adicional do conte√∫do
    const fileBuffer = await fs.readFile(req.file.path);
    const fileType = await FileType.fromBuffer(fileBuffer);
    
    if (!fileType || !ALLOWED_MIME_TYPES.includes(fileType.mime)) {
      // Remover arquivo inv√°lido
      await fs.unlink(req.file.path);
      return res.status(400).json({
        success: false,
        error: 'Arquivo corrompido ou tipo inv√°lido'
      });
    }
    
    // Mover para local definitivo
    const finalPath = `/var/uploads/user-${req.user!.id}/${req.file.filename}`;
    await fs.move(req.file.path, finalPath);
    
    console.log('üìÅ File uploaded successfully:', {
      userId: req.user!.id,
      filename: req.file.filename,
      size: req.file.size,
      mimetype: fileType.mime
    });
    
    res.json({
      success: true,
      fileId: req.file.filename
    });
  } catch (error) {
    console.error('‚ùå File upload failed:', {
      error: error.message,
      userId: req.user?.id
    });
    
    res.status(500).json({
      success: false,
      error: 'Falha no upload'
    });
  }
};
```

## üîç SECURITY MONITORING

### üìä **Audit Logging**
```typescript
// ‚úÖ CORRETO: Log de auditoria
interface AuditEvent {
  userId?: number;
  action: string;
  resource: string;
  resourceId?: string;
  ip: string;
  userAgent: string;
  timestamp: Date;
  success: boolean;
  details?: any;
}

export const auditLogger = {
  log: async (event: AuditEvent) => {
    // Log estruturado
    console.log('üîç Audit Event:', {
      ...event,
      timestamp: event.timestamp.toISOString()
    });
    
    // Persistir em banco
    await db.auditLog.create({
      data: event
    });
    
    // Alertas para eventos cr√≠ticos
    if (event.action === 'LOGIN_FAILED' && !event.success) {
      await securityAlerts.checkBruteForce(event.ip);
    }
  }
};

// Middleware de auditoria
export const auditMiddleware = (action: string, resource: string) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    const startTime = Date.now();
    
    res.on('finish', async () => {
      await auditLogger.log({
        userId: req.user?.id,
        action,
        resource,
        resourceId: req.params.id,
        ip: req.ip,
        userAgent: req.get('User-Agent') || '',
        timestamp: new Date(),
        success: res.statusCode < 400,
        details: {
          method: req.method,
          statusCode: res.statusCode,
          responseTime: Date.now() - startTime
        }
      });
    });
    
    next();
  };
};
```

### üö® **Rate Limiting**
```typescript
// ‚úÖ CORRETO: Rate limiting
import rateLimit from 'express-rate-limit';
import RedisStore from 'rate-limit-redis';

const createRateLimiter = (options: {
  windowMs: number;
  max: number;
  message: string;
  skipSuccessfulRequests?: boolean;
}) => {
  return rateLimit({
    store: new RedisStore({
      client: redisClient
    }),
    windowMs: options.windowMs,
    max: options.max,
    message: {
      success: false,
      error: options.message
    },
    skipSuccessfulRequests: options.skipSuccessfulRequests || false,
    keyGenerator: (req) => {
      // Combinar IP e user ID se autenticado
      return req.user ? `${req.ip}:${req.user.id}` : req.ip;
    }
  });
};

// Rate limiters espec√≠ficos
export const rateLimiters = {
  // Login attempts
  auth: createRateLimiter({
    windowMs: 15 * 60 * 1000, // 15 minutos
    max: 5, // 5 tentativas
    message: 'Muitas tentativas de login. Tente novamente em 15 minutos.'
  }),
  
  // API geral
  api: createRateLimiter({
    windowMs: 60 * 1000, // 1 minuto
    max: 100, // 100 requests
    message: 'Muitas requisi√ß√µes. Tente novamente em 1 minuto.',
    skipSuccessfulRequests: true
  }),
  
  // Cria√ß√£o de reservas
  reservation: createRateLimiter({
    windowMs: 60 * 1000, // 1 minuto
    max: 3, // 3 reservas por minuto
    message: 'Limite de reservas excedido. Aguarde 1 minuto.'
  })
};
```

## üìã SECURITY CHECKLIST

### ‚úÖ **Authentication & Authorization**
- [ ] **JWT Tokens**: Short-lived com refresh tokens
- [ ] **Password Hashing**: bcrypt com salt rounds >= 12
- [ ] **Session Management**: Secure cookies com httpOnly
- [ ] **Role-based Access**: Implementar RBAC adequado
- [ ] **Account Lockout**: Ap√≥s m√∫ltiplas tentativas falhadas

### ‚úÖ **Input Validation**
- [ ] **Schema Validation**: Zod em todas as entradas
- [ ] **Sanitiza√ß√£o**: HTML, SQL, filename sanitization
- [ ] **File Uploads**: Validar tipo, tamanho e conte√∫do
- [ ] **Rate Limiting**: Implementar em endpoints cr√≠ticos
- [ ] **CSRF Protection**: Tokens em formul√°rios

### ‚úÖ **Data Protection**
- [ ] **Encryption**: Dados sens√≠veis criptografados
- [ ] **HTTPS**: For√ßar SSL/TLS em produ√ß√£o
- [ ] **Secure Headers**: CSP, HSTS, X-Frame-Options
- [ ] **Data Minimization**: Coletar apenas dados necess√°rios
- [ ] **Backup Security**: Backups criptografados

### ‚úÖ **Monitoring & Logging**
- [ ] **Audit Logs**: Todas as a√ß√µes cr√≠ticas logadas
- [ ] **Error Handling**: N√£o vazar informa√ß√µes sens√≠veis
- [ ] **Security Alerts**: Monitorar tentativas de ataque
- [ ] **Vulnerability Scanning**: Depend√™ncias atualizadas
- [ ] **Penetration Testing**: Testes regulares de seguran√ßa

## üö´ SECURITY ANTI-PATTERNS

### ‚ùå **Vulnerabilidades Comuns**
```typescript
// ‚ùå INCORRETO: Vulnerabilidades graves
const badPractices = {
  // Hardcoded secrets
  JWT_SECRET: 'mysecret123',
  
  // SQL injection
  query: `SELECT * FROM users WHERE id = ${userId}`,
  
  // XSS vulnerability
  innerHTML: userInput,
  
  // Weak password validation
  passwordRegex: /^.{6,}$/,
  
  // No rate limiting
  login: async (req, res) => {
    // Sem prote√ß√£o contra brute force
  },
  
  // Information disclosure
  error: res.json({ error: error.stack })
};

// ‚úÖ CORRETO: Pr√°ticas seguras
const goodPractices = {
  JWT_SECRET: process.env.JWT_SECRET,
  query: db.user.findUnique({ where: { id: userId } }),
  innerHTML: DOMPurify.sanitize(userInput),
  passwordRegex: /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/,
  login: [rateLimiters.auth, loginController],
  error: res.json({ error: 'Internal server error' })
};
``` 