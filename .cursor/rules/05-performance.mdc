---
description: "Padr√µes de performance e otimiza√ß√£o baseados na metodologia THINK"
globs: ["**/*.ts", "**/*.tsx", "**/*.js", "**/*.jsx"]
alwaysApply: true
---

# üöÄ PERFORMANCE E OTIMIZA√á√ÉO - PADR√ïES MODERNOS

## ‚ö° PRINC√çPIOS DE PERFORMANCE

### üéØ **Performance by Default**
- Otimiza√ß√£o desde o in√≠cio, n√£o como afterthought
- M√©tricas de performance como crit√©rio de aceita√ß√£o
- Monitoramento cont√≠nuo de performance

### üìä **M√©tricas Obrigat√≥rias**
- **Loading Time**: < 3s para opera√ß√µes principais
- **API Response**: < 500ms para endpoints cr√≠ticos
- **Bundle Size**: Impacto m√≠nimo no tamanho final
- **Memory Usage**: Sem vazamentos de mem√≥ria
- **CPU Usage**: Opera√ß√µes eficientes

## üîß PADR√ïES DE OTIMIZA√á√ÉO

### ‚öõÔ∏è **React Performance Patterns**

#### üéØ **Optimistic Updates**
```typescript
const useOptimisticMutation = <TData, TError, TVariables>(
  mutationFn: (variables: TVariables) => Promise<TData>,
  options: OptimisticOptions<TData, TVariables> = {}
) => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn,
    onMutate: async (variables) => {
      await queryClient.cancelQueries(options.queryKey);
      const previousData = queryClient.getQueryData(options.queryKey);
      
      if (options.optimisticUpdate) {
        queryClient.setQueryData(
          options.queryKey,
          options.optimisticUpdate(previousData, variables)
        );
      }
      
      return { previousData };
    },
    onError: (error, variables, context) => {
      if (context?.previousData) {
        queryClient.setQueryData(options.queryKey, context.previousData);
      }
      toast.error('Opera√ß√£o falhou, tente novamente');
    },
    onSettled: () => {
      queryClient.invalidateQueries(options.queryKey);
    },
  });
};
```

#### üß† **Smart Caching Strategy**
```typescript
const useSmartCache = <T>(
  key: QueryKey,
  queryFn: QueryFunction<T>,
  options: SmartCacheOptions = {}
) => {
  const {
    staleTime = 5 * 60 * 1000, // 5min default
    cacheTime = 10 * 60 * 1000, // 10min default
    background = true
  } = options;
  
  return useQuery({
    queryKey: key,
    queryFn,
    staleTime,
    cacheTime,
    refetchOnWindowFocus: background,
    refetchOnReconnect: true,
    retry: (failureCount, error) => {
      if (error.status === 404) return false;
      if (error.status >= 500) return failureCount < 3;
      return failureCount < 1;
    },
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
  });
};
```

### üìä **Performance Monitoring**

#### üìà **Real-time Performance Tracking**
```typescript
const usePerformanceMonitor = () => {
  useEffect(() => {
    const observer = new PerformanceObserver((list) => {
      list.getEntries().forEach((entry) => {
        if (entry.entryType === 'measure') {
          analytics.track('performance_metric', {
            name: entry.name,
            duration: entry.duration,
            startTime: entry.startTime,
            component: getCurrentComponent()
          });
        }
      });
    });
    
    observer.observe({ entryTypes: ['measure'] });
    
    return () => observer.disconnect();
  }, []);
};
```

## üìã CHECKLIST DE PERFORMANCE

### ‚úÖ **Frontend Performance**
- [ ] **Bundle Size**: Analisado e otimizado
- [ ] **Code Splitting**: Implementado por rota/feature
- [ ] **Lazy Loading**: Componentes pesados carregados sob demanda
- [ ] **Image Optimization**: Formatos modernos (WebP, AVIF)
- [ ] **Caching Strategy**: Cache inteligente implementado
- [ ] **Re-render Prevention**: Memoization adequada

### ‚úÖ **API Performance**
- [ ] **Response Time**: < 500ms para endpoints cr√≠ticos
- [ ] **Request Batching**: M√∫ltiplas requests agrupadas
- [ ] **Connection Pooling**: Reutiliza√ß√£o de conex√µes
- [ ] **Compression**: Gzip/Brotli habilitado
- [ ] **CDN**: Assets servidos via CDN
- [ ] **Database Optimization**: Queries otimizadas

### ‚úÖ **UX Performance**
- [ ] **Loading States**: Skeleton loaders implementados
- [ ] **Progressive Loading**: Conte√∫do carregado incrementalmente
- [ ] **Optimistic Updates**: Feedback imediato ao usu√°rio
- [ ] **Error Recovery**: Retry autom√°tico para falhas tempor√°rias
- [ ] **Offline Support**: Funcionalidade b√°sica offline

## üö´ ANTI-PATTERNS DE PERFORMANCE

### ‚ùå **Re-renders Desnecess√°rios**
```typescript
// ‚ùå INCORRETO: Re-render a cada mudan√ßa
const Component = ({ data, onUpdate }) => {
  return (
    <div>
      {data.map(item => (
        <ItemComponent 
          key={item.id}
          item={item}
          onUpdate={() => onUpdate(item.id)} // Nova fun√ß√£o a cada render!
        />
      ))}
    </div>
  );
};

// ‚úÖ CORRETO: Callback memoizado
const Component = ({ data, onUpdate }) => {
  const handleUpdate = useCallback((id) => {
    onUpdate(id);
  }, [onUpdate]);
  
  return (
    <div>
      {data.map(item => (
        <ItemComponent 
          key={item.id}
          item={item}
          onUpdate={handleUpdate}
        />
      ))}
    </div>
  );
};
```

### ‚ùå **Memory Leaks**
```typescript
// ‚ùå INCORRETO: Event listeners n√£o removidos
useEffect(() => {
  const handleScroll = () => {
    // ...
  };
  
  window.addEventListener('scroll', handleScroll);
  // Sem cleanup!
}, []);

// ‚úÖ CORRETO: Cleanup adequado
useEffect(() => {
  const handleScroll = () => {
    // ...
  };
  
  window.addEventListener('scroll', handleScroll);
  
  return () => {
    window.removeEventListener('scroll', handleScroll);
  };
}, []);
```

### ‚ùå **Bundle Bloat**
```typescript
// ‚ùå INCORRETO: Import de biblioteca inteira
import _ from 'lodash';

// ‚úÖ CORRETO: Import espec√≠fico
import { debounce } from 'lodash/debounce';
// ou melhor ainda
import debounce from 'lodash.debounce';
``` 