---
description: "Estratégias de debugging e investigação baseadas na metodologia THINK"
globs: ["**/*"]
alwaysApply: true
---

# 🔍 DEBUGGING E INVESTIGAÇÃO - ESTRATÉGIAS SISTEMÁTICAS

## ⚡ PRINCÍPIOS DE DEBUGGING

### 🎯 **Investigação Paralela Obrigatória**
**SEMPRE usar múltiplas ferramentas simultaneamente:**
- `codebase_search`: Padrões similares no projeto
- `grep_search`: Imports e exports relacionados
- `read_file`: Arquivos mencionados em logs
- `file_search`: Componentes relacionados
- `web_search`: Soluções modernas para o problema

### 🔍 **Logging Estratégico por Camada**

#### 🌐 **Layer 1: Infrastructure & Network**
```typescript
console.log('🌐 Network Check:', {
  endpoint: process.env.API_URL,
  timeout: connectionTimeout,
  retryCount: retryAttempts,
  timestamp: new Date().toISOString()
});

console.log('📊 Performance:', {
  responseTime: Date.now() - startTime,
  memoryUsage: process.memoryUsage(),
  cpuUsage: process.cpuUsage()
});
```

#### 🔗 **Layer 2: API & Services**
```typescript
console.log('🔐 Auth Check:', {
  hasToken: !!token,
  tokenValid: token?.length > 10,
  userRoles: user?.roles,
  permissions: user?.permissions
});

console.log('📡 API Call:', {
  method: req.method,
  url: req.url,
  headers: sanitizeHeaders(req.headers),
  payload: sanitizePayload(req.body),
  correlationId: req.correlationId
});

console.log('📥 API Response:', {
  status: res.status,
  statusText: res.statusText,
  dataType: typeof res.data,
  dataSize: JSON.stringify(res.data || {}).length,
  correlationId: res.correlationId
});
```

#### ⚛️ **Layer 3: Frontend & UI**
```typescript
console.log('⚛️ Component:', {
  name: ComponentName,
  phase: 'mount|update|unmount',
  props: sanitizeProps(props),
  state: sanitizeState(state),
  renderCount: renderCountRef.current++
});

console.log('📊 Data Flow:', {
  received: !!data,
  processed: !!processedData,
  loading: isLoading,
  error: error?.message,
  cacheHit: isCacheHit
});

console.log('🔄 State Change:', {
  component: ComponentName,
  from: prevState,
  to: newState,
  trigger: actionType,
  timestamp: Date.now()
});
```

## 🕵️ ESTRATÉGIAS DE INVESTIGAÇÃO

### 🔍 **Para Bugs de UI**
```bash
# Execute SIMULTANEAMENTE:
- codebase_search: "componente relacionado"
- grep_search: "estilos CSS relacionados"
- file_search: "hooks e contexts"
- web_search: "react [erro específico] 2024"
```

### 🔍 **Para Bugs de API**
```bash
# Execute SIMULTANEAMENTE:
- codebase_search: "endpoint relacionado"
- grep_search: "service layer"
- read_file: "controller + middleware"
- web_search: "nodejs [erro] best practices"
```

### 🔍 **Para Bugs de Database**
```bash
# Execute SIMULTANEAMENTE:
- codebase_search: "schema relacionado"
- grep_search: "queries relacionadas"
- read_file: "migration files"
- web_search: "prisma [erro] solution"
```

## ⚠️ ARMADILHAS COMUNS A EVITAR

### 🔍 **Armadilhas Técnicas**
- **Double Data Access**: Serviços já fazem parsing
- **Type Mismatches**: TypeScript vs runtime
- **State Sync Issues**: Estado não atualizado
- **Cache Invalidation**: Dados obsoletos
- **Race Conditions**: Concorrência não tratada
- **Memory Leaks**: Recursos não liberados
- **Error Boundaries**: Erros não capturados

### 🏗️ **Armadilhas Arquiteturais**
- **Tight Coupling**: Dependências desnecessárias
- **Single Point of Failure**: Componente crítico único
- **Over-Engineering**: Solução mais complexa que o problema
- **Technical Debt**: Soluções temporárias permanentes
- **Performance Bottlenecks**: Gargalos não identificados

### 👥 **Armadilhas de Processo**
- **Assumption Bias**: Premissas não validadas
- **Confirmation Bias**: Buscar só evidências que confirmam
- **Scope Creep**: Expansão não controlada do problema
- **Communication Gap**: Informações não compartilhadas
- **Solution Bias**: Pular direto para implementação

## 🎯 MATRIZ DE PRIORIZAÇÃO DE HIPÓTESES

### 📊 **Sistema de Score 4D**
Para cada hipótese, avalie:
- **📊 Probabilidade**: 1-10 (baseado em evidências)
- **🧪 Testabilidade**: 1-10 (facilidade de verificar)
- **💥 Impacto**: 1-10 (consequências se for a causa)
- **⏱️ Effort**: 1-10 (tempo/recursos para investigar/corrigir)

### 🎯 **Fórmula de Priorização**
```
Score = (Probabilidade × 3) + (Impacto × 2) + (10 - Effort) + Testabilidade
```

### 🥇 **Matriz de Execução**
```
┌─────────────────┬──────────────────┬──────────────────┐
│ SCORE > 30      │ SCORE 20-30      │ SCORE < 20       │
├─────────────────┼──────────────────┼──────────────────┤
│ 🥇 PRIMEIRA     │ 🥈 SEGUNDA       │ 🥉 TERCEIRA      │
│ (Fácil + Alta)  │ (Balanceada)     │ (Difícil/Baixa)  │
└─────────────────┴──────────────────┴──────────────────┘
```

## 🔄 PROTOCOLO DE ITERAÇÃO

### 📊 **Decision Matrix para Próximos Passos**
```
🔍 ANÁLISE DE FALHA:
├── 🎯 Hipótese Errada?
│   └── Voltar para PASSO 2 (REFLECT) com novos dados
├── 🛠️ Implementação Defeituosa?
│   └── Revisar PASSO 4 (EXECUTE) com feedback
├── 📋 Plano Inadequado?
│   └── Ajustar PASSO 3 (PLAN) baseado em learnings
└── 🧠 Problema Mal Definido?
    └── Retornar para PASSO 1 (THINK) para redefinir
```

### 🚨 **Protocolo de Segurança**
```typescript
interface IterationProtocol {
  maxIterations: number;        // Máximo 3 iterações
  timeboxing: number;          // Máximo 8h por iteração
  escalationTriggers: {
    timeExceeded: boolean;     // > 24h total
    complexityHigh: boolean;   // Score > 8/10
    stakeholderBlock: boolean; // Decisão externa necessária
  };
  
  exitStrategy: {
    documentLearnings: boolean;
    escalateToSenior: boolean;
    scheduleFollowUp: boolean;
  };
}
```

## 🌐 RESEARCH SISTEMÁTICO

### 🔍 **Estratégia Multi-Canal**
```
🎯 CANAIS PRIORITÁRIOS:
1. 📚 Official Documentation (sempre primeiro)
2. 🐙 GitHub Issues (problemas similares resolvidos)
3. 💬 Stack Overflow (soluções da comunidade)
4. 📖 Best Practices Guides (padrões estabelecidos)
5. 🎥 Technical Talks/Blogs (insights avançados)
6. 👥 Internal Knowledge Base (experiências da equipe)
```

### 🕐 **Time-Boxing Research**
- **⚡ Quick Research**: 15 min para problemas simples
- **🔍 Deep Dive**: 30-45 min para problemas complexos
- **🎯 Focused Search**: Usar keywords específicas + ano
- **📋 Document Findings**: Sempre registrar insights úteis

## 🧪 DEBUGGING PATTERNS

### 🔍 **Rastreamento de Dados**
```typescript
// Service Layer - Logging defensivo
console.log('📥 Service Input:', JSON.stringify(params, null, 2));
console.log('🔄 Service Processing:', { step: 'validation', valid: !!data });
console.log('📤 Service Output:', { type: typeof result, length: result?.length });

// Component Layer - Estado e props
console.log('⚛️ Component Mount:', { props, initialState });
console.log('🔄 State Change:', { from: prevState, to: newState });
console.log('📊 Render Data:', { received: !!data, processed: processedData?.length });
```

### 🎯 **Performance Debugging**
```typescript
const usePerformanceMonitor = () => {
  useEffect(() => {
    const observer = new PerformanceObserver((list) => {
      list.getEntries().forEach((entry) => {
        if (entry.entryType === 'measure') {
          analytics.track('performance_metric', {
            name: entry.name,
            duration: entry.duration,
            startTime: entry.startTime,
            component: getCurrentComponent()
          });
        }
      });
    });
    
    observer.observe({ entryTypes: ['measure'] });
    return () => observer.disconnect();
  }, []);
};
```

## 🚫 PROIBIÇÕES EM DEBUGGING

- ❌ NUNCA assumir sem validar
- ❌ NUNCA investigar apenas uma hipótese por vez
- ❌ NUNCA fazer mudanças sem logging
- ❌ NUNCA parar na primeira solução que funciona
- ❌ NUNCA deixar de documentar a causa raiz

## ✅ COMPORTAMENTOS OBRIGATÓRIOS

- ✅ SEMPRE usar investigação paralela
- ✅ SEMPRE implementar logging em múltiplas camadas
- ✅ SEMPRE priorizar hipóteses por score
- ✅ SEMPRE documentar findings e learnings
- ✅ SEMPRE validar fix com testes abrangentes 